%% examples/doublewell_Duffing_main.m
% HBSS_Cont - Example: double-well Duffing oscillator
% Input to solver: matrices A, Be, C, De and Ts (continuous/discrete)

clearvars; close all; clc;

%% Setup path (HBSS_Cont)
thisFile = mfilename('fullpath');
thisDir  = fileparts(thisFile);          % .../examples/ex_5dof_chain
examplesDir = fileparts(thisDir);        % .../examples
rootDir     = fileparts(examplesDir);    % .../HBSS_Cont
srcDir = fullfile(rootDir, 'src');
addpath(srcDir);

%% ---- User defined parameters ----

% =========================
% Harmonic Balance
% =========================
Harmonics = 0:7;           % Harmonic indices [0 1 ... H]
nSamples  = 512;           % Time samples for AFT

% =========================
% Frequency range
% =========================
fLim = [4 16];             % Frequency range [Hz]

% =========================
% Forcing
% =========================
F0 = 34/10;                 % Amplitude of harmonic forcing

% =========================
% Scaling (important!)
% =========================
% Scaling factor for harmonic coefficients (improves numerical conditioning)
% scaleY = 'auto';              % Typical order: 1e2 – 1e4
scaleY = 1e4;

% =========================
% Pseudo-Arc-Length Continuation (PALC)
% =========================
% hmax: maximum allowed change per continuation step
%       (in scaled harmonic coefficients)
% hmin: minimum step size before stopping
hmax = 0.2;               
hmin = 1e-3;              

% =========================
% Plotting
% =========================
chOut = 1;                 % Output channel to plot (index)

% =========================
% Nonlinear solver (fsolve)
% =========================
% These parameters control the local Newton solver used
% inside each continuation corrector step
TolFun  = 1e-10;           % Function tolerance
TolX    = 1e-10;           % Variable tolerance
MaxIter = 20;              % Max Newton iterations per fsolve call

%% ---- Load state-space model ----
load ssmodel;

% Discrete-time model
Ts=1/fs;

% Number of output channels
ny = size(C,1);

% Inputs: extended u_e
% u applied at DOF 1, nonlinear channels applied through B directions.

%% ---- Nonlinearities g_j(y,yd) ----
% y, yd are ny×N (AFT) or ny×1 (stability FD/analytic)

% Nonlinear basis functions: vector of clearances
J = size(Be,2)-1;                 % number of nonlinear terms
fNL = cell(J,1);
fNL{1} = @(x,xd) x(1,:).^3;
fNL{2} = @(x,xd) x(1,:).^2;


%% ---- Analytic derivatives dFNL: cell (nNL x ny) ----
%%%% Comment this section to use numerical Jacobian %%%%
%%%% dFNL{inl, j}(y,yd) = ∂ fNL_inl / ∂ y_j   (same size as y(1,:))

dFNL = cell(J,1);   % J x 1 (nNL x ny), ny = 1
dFNL{1,1} = @(y,yd)  3*(y(1,:)).^2;
dFNL{2,1} = @(y,yd)  2*(y(1,:)).^1;

%% ---- Forcing (physical input only) ----

% Extended input is [u; g1..], so:
nNL = numel(fNL);
nu  = size(Be,2);
nForc = nu - nNL;  % here should be 1
assert(nForc == 1, 'This example expects exactly 1 physical forcing input.');

F = zeros(nForc, numel(Harmonics));
F(1, Harmonics==1) = F0;

%% ---- Build HB struct (matrices-only API) ----
HB = struct();
HB.A  = A; HB.Be = Be;
HB.C  = C; HB.De = De;
HB.Ts = Ts;
HB.Harmonics = Harmonics;
HB.fLim      = fLim;
HB.scaleY    = scaleY;
HB.nSamples  = nSamples;
HB.F = F;
HB.cont = struct('hmax',hmax,'hmin',hmin);
HB.plot = struct('enable',true,'chOut',chOut);
HB.solver = struct();
HB.solver.name = 'fsolve';
HB.solver.opts = optimoptions('fsolve','TolFun',TolFun,'TolX',TolX, ...
    'MaxIter',MaxIter);

HB.NL = struct();
HB.NL.fNL  = fNL;
try
    HB.NL.dFNL = dFNL;    % <- analytic Jacobian of NL (recommended)
catch
    % If no dFNL is defined -> numerical Jacobian
end

%% ---- Run ----
out = hbss_continuation(HB);

%% ---- Post plot (NFRC) ----
chPlot = 1;   % output channel
hPlot  = 1;   % harmonic contribution

hbss_plot_nfrc(out, chPlot, hPlot);